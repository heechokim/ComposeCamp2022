> 문서 읽고 굉장히 짧게 핵심만 기록  
> [1주차 컴포즈 스터디 코스 링크](https://developer.android.com/courses/pathways/jetpack-compose-for-android-developers-1)  
> 
> [문서 1 > Jetpack 컴포즈 스타터들을 위한 튜토리얼](https://developer.android.com/jetpack/compose/tutorial?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fjetpack-compose-for-android-developers-1%23article-https%3A%2F%2Fdeveloper.android.com%2Fjetpack%2Fcompose%2Ftutorial) -> 읽기 완료  
> [문서 2 > Compose 개요](https://youtu.be/7Mf2175h3RQ) -> 읽기 완료  
> [문서 3 > Compose 이해](https://developer.android.com/jetpack/compose/mental-model?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fjetpack-compose-for-android-developers-1%23article-https%3A%2F%2Fdeveloper.android.com%2Fjetpack%2Fcompose%2Fmental-model) -> 읽는 중

# 👊🏻 문서 1 > Jetpack 컴포즈 스타터들을 위한 튜토리얼

#### Lesson 1 : Composable functions 요약

- 컴포즈는 Jetpack 라이브러리에 속한, 새로운 안드로이드 UI 툴킷이다
- 이제 XML 레이아웃? 필요 없음
- XML 레이아웃 만드는 대신, composable 함수만 만들어서 호출만 하면 된다
- 컴포즈 컴파일러가 컴파일해서 UI 만들어 줌
- 이게 선언형 UI 
- 컴포저블 함수 만들 때는 `@Composable` 어노테이션을 함수 위에 붙인다
- `setContent` 블록 안에서 컴포저블 함수 호출
- 컴포즈는 앱 빌드 없이 미리 보기 가능
- `@Composable` 어노테이션 위에 `@Preview` 어노테이션을 붙이면 됨
- 새로운 프리뷰 붙은 컴포저블 함수를 만들면 안드로이드 스튜디오가 인식하도록 맨 처음에만 Rebuild 한 번 해주고
- 컴포저블 함수를 수정할 때에는 Refresh만 해주면 된다

#### Lesson 2 : Layouts 요약

- Column / Row / Box 로 레이아웃을 구성할 수 있음
- 레이아웃 안에 여러 개의 Text를 넣거나 하는 식임
- Modifier로 뷰의 모양을 설정해줌(size, width, height 등)
- (기존 XML 레이아웃 방식의 속성들을 모두 Modifier로 지정한다고 생각하면 될 듯)

#### Lesson 3 : Material Design

- 컴포즈는 머티리얼 디자인도 지원해준다
- style로 MaterialTheme 에서 지원해주는 여러 스타일을 지정할 수 있음
- `Surface` 컴포저블 함수로는 뷰의 모양을 만들 수 있음(border, shape 등)
- 다크모드도 지원
- 프리뷰에 다크모드로 보도록 설정할 수도 있음

#### Lesson 4 : Lists and animations

- 리스트는 LazyColumn 이랑 LazyRow 사용해서 구현하면 된다
- 컴포즈는 UI 상태를 추적하기 위한 state API인 `remember`이랑 `mutableStateOf` 제공한다
- UI 상태가 변경되면 자동으로 UI가 다시 렌더링되도록 구현 가능
- `Modifier.animateXX()` 로는 애니메이션도 설정 가능

# 👊🏻 문서 2 > Compose 개요

#### 구글이 컴포즈를 등장시킨 이유
- 기존 View 클래스 기반 UI 도구는 10년 넘음
- 시간 지나며 안드로이드 개발 기술도 발전 했다(모던 아키텍처, Kotlin 등)
- 디바이스 성능도 좋아졌고
- UI가 더 동적여지길 원하는 앱 증가
- 이런 환경에 맞는 더 최신화된 UI 도구의 필요성 증가

#### 컴포즈가 기존 View 클래스 기반 UI 도구보다 좋은 이유
- 기존
  - 사용자와 앱의 상호 작용 > 앱 데이터 업데이트 > state 업데이트 > UI 업데이트 순서로 UI가 업데이트 된다
  - findViewById()로 뷰 직접 찾아서 setText()를 해줘야 업데이트 됨
  - 이런 방식으로 업데이트 해야할 뷰의 수가 많음
  - 개발자가 빠뜨리는 부분도 많고 번거로움
- 컴포즈
  - state가 업데이트 되면 UI를 업데이트 하는 방식이 아니다
  - state가 업데이트 되면 아예 새로 UI를 다시 생성하는 방식
  - 개발자가 하나 하나 업데이트 시키지 않음
  - 컴포즈가 state를 구독하고 자동으로 새로운 UI 생성하기 때문

#### 컴포즈 동작 원리
- 일단 코틀린과 UI 도구를 자유 자재로 컴포저블 함수 내에서 같이 사용 가능
- <img width="422" alt="image" src="https://user-images.githubusercontent.com/31889335/201123291-b3d0daa3-776b-4ea9-a4af-7003c122a09a.png">
- 코드 분석
  - 컴포저블 함수의 파라미터로 데이터 전달
  - 데이터에 따라 Text를 다르게 표시할 수 있다
  - 이 때 코틀린 if 식 사용 가능
  - 컴포저블 함수는 거의 대부분 파라미터를 갖는다
  - 파라미터가 state 역할을 한다
- <img width="555" alt="image" src="https://user-images.githubusercontent.com/31889335/201123983-79b7343e-5ccf-4c92-a179-8ced80559eef.png">
- 코드 분석
  - viewModel에 정의된 LiveData로 감싸진 state를 컴포저블 파라미터로 전달하면 끝
  - state가 업데이트되면 자동으로 컴포저블 함수가 호출되면서 UI가 새로 생성되는 방식
  - viewModel.uiState.observe { binding.button.text = "" } 식의 코드 필요 없어짐
  - 컴포저블 함수를 만들고 파라미터에 state 전달하면 끝
- 컴포즈 컴파일러는 state가 업데이트 된 컴포저블 함수만 실행시킨다 나머지 함수는 건너뜀

# 👊🏻 문서 3 > Compose 이해

